name: Release

on:
  schedule:
    - cron: '0 18 * * *' # Every day at 6pm UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y bats jq ripgrep
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Run tests
        run: bats tests

  release:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for new commits since last tag
        id: check
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "last_tag=$LAST_TAG" >> "$GITHUB_OUTPUT"

          if [ -n "$LAST_TAG" ]; then
            COMMIT_COUNT=$(git rev-list "$LAST_TAG"..HEAD --count)
          else
            COMMIT_COUNT=$(git rev-list HEAD --count)
          fi
          echo "commit_count=$COMMIT_COUNT" >> "$GITHUB_OUTPUT"

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits since $LAST_TAG — skipping release."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "$COMMIT_COUNT new commits since ${LAST_TAG:-beginning}"
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine version bump from conventional commits
        if: steps.check.outputs.skip == 'false'
        id: version
        run: |
          LAST_TAG="${{ steps.check.outputs.last_tag }}"

          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log "$LAST_TAG"..HEAD --pretty=format:"%s")
          else
            COMMITS=$(git log --pretty=format:"%s")
          fi

          # Default to patch bump
          BUMP="patch"

          # Look for feature-related words anywhere in commit messages → minor
          if echo "$COMMITS" | grep -qiE '\bfeat(ure)?s?\b|\badd(ed|s)?\b|\bnew\b|\bintroduc'; then
            BUMP="minor"
          fi

          # Look for breaking change signals → major
          HAS_BREAKING=false
          if echo "$COMMITS" | grep -qiE '\bbreaking\b'; then
            HAS_BREAKING=true
          fi
          if [ -n "$LAST_TAG" ]; then
            if git log "$LAST_TAG"..HEAD --pretty=format:"%b" | grep -qiE '\bbreaking\b'; then
              HAS_BREAKING=true
            fi
          fi
          if [ "$HAS_BREAKING" = true ]; then
            BUMP="major"
          fi

          if [ -z "$LAST_TAG" ]; then
            NEW_VERSION="v0.1.0"
          else
            CURRENT="${LAST_TAG#v}"
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
            case "$BUMP" in
              major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
              patch) PATCH=$((PATCH + 1)) ;;
            esac
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "bump=$BUMP" >> "$GITHUB_OUTPUT"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "Version: $NEW_VERSION (${BUMP} bump)"

      - name: Generate changelog
        if: steps.check.outputs.skip == 'false'
        id: changelog
        run: |
          LAST_TAG="${{ steps.check.outputs.last_tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          if [ -n "$LAST_TAG" ]; then
            RAW=$(git log "$LAST_TAG"..HEAD --pretty=format:"%s|%h")
          else
            RAW=$(git log --pretty=format:"%s|%h")
          fi

          BREAKING=""
          FEATURES=""
          FIXES=""
          OTHER=""

          while IFS='|' read -r msg hash; do
            [ -n "$msg" ] || continue
            entry="- ${msg} (${hash})"
            if echo "$msg" | grep -qiE '\bbreaking\b'; then
              BREAKING+="${entry}"$'\n'
            elif echo "$msg" | grep -qiE '\bfeat(ure)?s?\b|\badd(ed|s)?\b|\bnew\b|\bintroduc'; then
              FEATURES+="${entry}"$'\n'
            elif echo "$msg" | grep -qiE '\bfix(ed|es)?\b|\bbug\b|\bpatch\b|\bhotfix\b'; then
              FIXES+="${entry}"$'\n'
            else
              OTHER+="${entry}"$'\n'
            fi
          done <<< "$RAW"

          CHANGELOG="## ${VERSION}"$'\n\n'
          [ -n "$BREAKING" ] && CHANGELOG+="### Breaking Changes"$'\n'"${BREAKING}"$'\n'
          [ -n "$FEATURES" ] && CHANGELOG+="### Features"$'\n'"${FEATURES}"$'\n'
          [ -n "$FIXES" ] && CHANGELOG+="### Bug Fixes"$'\n'"${FIXES}"$'\n'
          [ -n "$OTHER" ] && CHANGELOG+="### Other Changes"$'\n'"${OTHER}"$'\n'

          {
            echo "body<<CHANGELOG_EOF"
            echo "$CHANGELOG"
            echo "CHANGELOG_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create tag and release
        if: steps.check.outputs.skip == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "$VERSION"
          git push origin "$VERSION"

          gh release create "$VERSION" \
            --title "$VERSION" \
            --notes "${{ steps.changelog.outputs.body }}"

          echo "Created release $VERSION"

      - name: Update Homebrew formula
        if: steps.check.outputs.skip == 'false'
        env:
          TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          REPO="gabrielkoerich/orchestrator"
          URL="https://github.com/${REPO}/archive/refs/tags/${VERSION}.tar.gz"
          TAP_REPO="gabrielkoerich/homebrew-tap"

          # Download archive and compute sha256
          SHA256=$(curl -sL "$URL" | sha256sum | awk '{print $1}')
          echo "SHA256: $SHA256"

          if [ -z "${TAP_TOKEN}" ]; then
            echo "HOMEBREW_TAP_TOKEN secret is required to push to ${TAP_REPO}"
            exit 1
          fi

          git clone "https://x-access-token:${TAP_TOKEN}@github.com/${TAP_REPO}.git" tap-repo
          mkdir -p tap-repo/Formula

          cat > tap-repo/Formula/orchestrator.rb <<EOF
          class Orchestrator < Formula
            desc "Multi-agent task orchestrator for AI coding agents (claude, codex, opencode)"
            homepage "https://github.com/gabrielkoerich/orchestrator"
            url "https://github.com/gabrielkoerich/orchestrator/archive/refs/tags/${VERSION}.tar.gz"
            sha256 "${SHA256}"
            head "https://github.com/gabrielkoerich/orchestrator.git", branch: "main"
            license "MIT"

            depends_on "yq"
            depends_on "jq"
            depends_on "just"
            depends_on "python@3"

            def install
              libexec.install "scripts", "prompts", "justfile"
              libexec.install Dir["*.example.yml"]
              libexec.install "tests" if (buildpath/"tests").exist?

              (bin/"orchestrator").write <<~EOS
                #!/usr/bin/env bash
                set -euo pipefail

                export PROJECT_DIR="\${PROJECT_DIR:-\$(pwd)}"
                export ORCH_HOME="\${ORCH_HOME:-\$HOME/.orchestrator}"

                mkdir -p "\$ORCH_HOME"

                # State paths (persistent in user home)
                export TASKS_PATH="\${TASKS_PATH:-\$ORCH_HOME/tasks.yml}"
                export JOBS_PATH="\${JOBS_PATH:-\$ORCH_HOME/jobs.yml}"
                export CONFIG_PATH="\${CONFIG_PATH:-\$ORCH_HOME/config.yml}"
                export STATE_DIR="\${STATE_DIR:-\$ORCH_HOME/.orchestrator}"
                export CONTEXTS_DIR="\${CONTEXTS_DIR:-\$ORCH_HOME/contexts}"
                export LOCK_PATH="\${LOCK_PATH:-\$TASKS_PATH.lock}"

                # Code lives in Homebrew libexec
                cd "#{libexec}"
                exec just "\$@"
              EOS
            end

            service do
              run [opt_bin/"orchestrator", "serve"]
              keep_alive true
              log_path var/"log/orchestrator.log"
              error_log_path var/"log/orchestrator.error.log"
            end

            def caveats
              <<~EOS
                To get started:
                  cd ~/your-project
                  orchestrator init         # configure project
                  orchestrator add "title"  # add a task
                  orchestrator serve        # start the server

                Background service (auto-start on login):
                  brew services start orchestrator

                Required agent CLIs (install at least one):
                  brew install --cask claude-code   # Claude
                  brew install --cask codex         # Codex
                  brew install opencode             # OpenCode

                Optional for GitHub sync:
                  brew install gh && gh auth login
              EOS
            end

            test do
              assert_match "orchestrator", shell_output("#{bin}/orchestrator 2>&1", 0)
            end
          end
          EOF

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git -C tap-repo config user.name "github-actions[bot]"
          git -C tap-repo config user.email "github-actions[bot]@users.noreply.github.com"
          git -C tap-repo add Formula/orchestrator.rb
          if git -C tap-repo diff --cached --quiet; then
            echo "Homebrew formula unchanged"
            exit 0
          fi
          git -C tap-repo commit -m "chore: update orchestrator formula for ${VERSION}"
          git -C tap-repo push origin main
